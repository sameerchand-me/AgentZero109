"""
Report & Evidence Agent - Generates triager-optimized vulnerability reports
Minimal reproduction steps, clear impact, business-focused
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime
import json
from jinja2 import Template


@dataclass
class ReportEvidence:
    """Evidence for a vulnerability report"""
    evidence_type: str  # 'screenshot', 'http_log', 'video', 'code'
    description: str
    content: str
    timestamp: datetime


class ReportAgent:
    """
    Generates professional, triager-optimized bug bounty reports
    Focuses on clarity, reproduction, and business impact
    """
    
    def __init__(self):
        self.reports: List[Dict[str, Any]] = []
        
    def generate_report(
        self,
        vulnerability: Dict[str, Any],
        evidence: List[ReportEvidence],
        validation_data: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Generate a complete vulnerability report
        
        Args:
            vulnerability: Vulnerability data
            evidence: List of evidence items
            validation_data: Validation results
        
        Returns:
            Formatted report string
        """
        report_template = self._get_report_template()
        
        report_data = {
            'title': self._generate_title(vulnerability),
            'severity': vulnerability.get('severity', 'Medium').upper(),
            'vuln_type': vulnerability.get('type', 'Unknown'),
            'summary': self._generate_summary(vulnerability),
            'business_impact': self._generate_business_impact(vulnerability),
            'reproduction_steps': self._format_reproduction_steps(
                vulnerability.get('reproduction_steps', [])
            ),
            'expected_behavior': vulnerability.get('expected_behavior', 'N/A'),
            'actual_behavior': vulnerability.get('actual_behavior', 'N/A'),
            'affected_endpoints': vulnerability.get('affected_endpoints', []),
            'evidence': self._format_evidence(evidence),
            'validation': self._format_validation(validation_data),
            'remediation': self._generate_remediation(vulnerability),
            'references': self._generate_references(vulnerability),
            'cvss_score': self._calculate_cvss(vulnerability),
            'timestamp': datetime.now().isoformat()
        }
        
        template = Template(report_template)
        report = template.render(**report_data)
        
        self.reports.append({
            'vulnerability': vulnerability,
            'report': report,
            'timestamp': datetime.now()
        })
        
        return report
    
    def _get_report_template(self) -> str:
        """Get the report template"""
        return """
# {{ title }}

**Severity:** {{ severity }}  
**Type:** {{ vuln_type }}  
**Reported:** {{ timestamp }}  
**CVSS Score:** {{ cvss_score }}

---

## Summary

{{ summary }}

---

## Business Impact

{{ business_impact }}

---

## Reproduction Steps

{{ reproduction_steps }}

---

## Expected vs Actual Behavior

### Expected Behavior
{{ expected_behavior }}

### Actual Behavior
{{ actual_behavior }}

---

## Affected Endpoints

{% for endpoint in affected_endpoints %}
- `{{ endpoint }}`
{% endfor %}

---

## Evidence

{{ evidence }}

---

## Validation Results

{{ validation }}

---

## Remediation Recommendations

{{ remediation }}

---

## References

{{ references }}

---

**Report generated by AgentZero109**  
*Precision bug hunting system focused on high-value vulnerabilities*
"""
    
    def _generate_title(self, vulnerability: Dict[str, Any]) -> str:
        """Generate concise, descriptive title"""
        vuln_type = vulnerability.get('type', 'Vulnerability').replace('_', ' ').title()
        endpoint = vulnerability.get('affected_endpoints', ['Unknown'])[0]
        
        # Extract path from full URL
        if 'http' in endpoint:
            from urllib.parse import urlparse
            endpoint = urlparse(endpoint).path
        
        return f"{vuln_type} in {endpoint}"
    
    def _generate_summary(self, vulnerability: Dict[str, Any]) -> str:
        """Generate executive summary"""
        desc = vulnerability.get('description', '')
        vuln_type = vulnerability.get('type', 'vulnerability')
        severity = vulnerability.get('severity', 'medium')
        
        summary = f"A {severity}-severity {vuln_type} vulnerability was identified. "
        
        if desc:
            summary += desc
        else:
            summary += f"This vulnerability allows an attacker to exploit {vuln_type} weaknesses."
        
        return summary
    
    def _generate_business_impact(self, vulnerability: Dict[str, Any]) -> str:
        """Generate business impact section"""
        impact = vulnerability.get('business_impact', '')
        
        if impact:
            return impact
        
        # Generate based on type
        vuln_type = vulnerability.get('type', '').lower()
        severity = vulnerability.get('severity', 'medium').lower()
        
        impact_templates = {
            'idor': "**Critical Risk:** Unauthorized access to user data. Attackers can view/modify other users' sensitive information, leading to data breaches and privacy violations.",
            'privilege_escalation': "**Critical Risk:** Attackers can gain administrative access, potentially compromising the entire application and all user data.",
            'sql_injection': "**Critical Risk:** Full database compromise possible. Attackers can extract, modify, or delete sensitive data, potentially affecting all users.",
            'account_takeover': "**Critical Risk:** Complete account compromise. Attackers can take over arbitrary user accounts without authentication.",
            'business_logic': "**High Risk:** Business process can be exploited for financial gain or service abuse, directly impacting revenue and operations.",
            'ssrf': "**High Risk:** Internal network access and potential cloud credential exposure. Can lead to infrastructure compromise.",
        }
        
        for key, template in impact_templates.items():
            if key in vuln_type:
                return template
        
        return f"**{severity.title()} Risk:** This vulnerability poses security risks that should be addressed promptly."
    
    def _format_reproduction_steps(self, steps: List[str]) -> str:
        """Format reproduction steps for clarity"""
        if not steps:
            return "Reproduction steps not provided."
        
        formatted = []
        for i, step in enumerate(steps, 1):
            # Clean up step formatting
            step = step.strip()
            if not step.startswith(str(i)):
                formatted.append(f"{i}. {step}")
            else:
                formatted.append(step)
        
        return '\n'.join(formatted)
    
    def _format_evidence(self, evidence: List[ReportEvidence]) -> str:
        """Format evidence section"""
        if not evidence:
            return "No additional evidence provided."
        
        formatted = []
        for i, item in enumerate(evidence, 1):
            formatted.append(f"### Evidence {i}: {item.evidence_type.title()}")
            formatted.append(f"{item.description}\n")
            
            if item.evidence_type == 'http_log':
                formatted.append("```http")
                formatted.append(item.content)
                formatted.append("```\n")
            elif item.evidence_type == 'code':
                formatted.append("```")
                formatted.append(item.content)
                formatted.append("```\n")
            else:
                formatted.append(f"{item.content}\n")
        
        return '\n'.join(formatted)
    
    def _format_validation(self, validation_data: Optional[Dict[str, Any]]) -> str:
        """Format validation results"""
        if not validation_data:
            return "Validation pending."
        
        result = validation_data.get('result', 'unknown')
        confidence = validation_data.get('confidence', 'medium')
        
        formatted = [
            f"**Validation Result:** {result.upper()}",
            f"**Confidence Level:** {confidence.upper()}",
        ]
        
        if 'evidence' in validation_data:
            formatted.append("\n**Validation Evidence:**")
            for evidence in validation_data['evidence']:
                formatted.append(f"- {evidence}")
        
        return '\n'.join(formatted)
    
    def _generate_remediation(self, vulnerability: Dict[str, Any]) -> str:
        """Generate remediation recommendations"""
        vuln_type = vulnerability.get('type', '').lower()
        
        remediation_templates = {
            'idor': """
1. **Implement Authorization Checks:** Verify that the requesting user owns/can access the requested resource
2. **Use Indirect References:** Replace direct object IDs with random, unpredictable references
3. **Validate Access on Every Request:** Never trust client-provided IDs without server-side validation
4. **Apply Principle of Least Privilege:** Users should only access their own resources by default
""",
            'sql_injection': """
1. **Use Parameterized Queries:** Replace string concatenation with prepared statements
2. **Input Validation:** Whitelist and sanitize all user inputs
3. **Least Privilege Database Access:** Application should use database accounts with minimum required permissions
4. **Web Application Firewall:** Deploy WAF rules to detect and block SQLi attempts
""",
            'privilege_escalation': """
1. **Enforce Role-Based Access Control (RBAC):** Validate user permissions on every privileged operation
2. **Never Trust Client-Side Role Data:** Always verify roles server-side
3. **Audit Privilege Changes:** Log and monitor all privilege escalation attempts
4. **Implement Permission Checks:** Validate authorization at both application and database layers
""",
            'business_logic': """
1. **Server-Side Validation:** Never trust client-provided data for critical business logic
2. **State Management:** Track and validate workflow state transitions
3. **Add Rate Limiting:** Prevent abuse through request rate controls
4. **Idempotency:** Ensure operations can't be replayed maliciously
5. **Price/Quantity Recalculation:** Always recalculate values server-side
""",
            'ssrf': """
1. **Whitelist Allowed Hosts:** Only allow connections to explicitly approved external services
2. **Disable Internal Access:** Block requests to private IP ranges (RFC1918)
3. **URL Validation:** Validate and sanitize all user-provided URLs
4. **Network Segmentation:** Isolate application servers from internal infrastructure
""",
        }
        
        for key, template in remediation_templates.items():
            if key in vuln_type:
                return template.strip()
        
        return """
1. **Implement Proper Validation:** Validate all user inputs and enforce security controls
2. **Follow Security Best Practices:** Apply defense-in-depth principles
3. **Regular Security Testing:** Conduct periodic security assessments
4. **Security Training:** Ensure development team follows secure coding practices
"""
    
    def _generate_references(self, vulnerability: Dict[str, Any]) -> str:
        """Generate reference links"""
        vuln_type = vulnerability.get('type', '').lower()
        
        references = {
            'idor': [
                "- [OWASP: Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)",
                "- [PortSwigger: Access Control Vulnerabilities](https://portswigger.net/web-security/access-control)"
            ],
            'sql_injection': [
                "- [OWASP: SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)",
                "- [OWASP: SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)"
            ],
            'ssrf': [
                "- [OWASP: Server Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/)",
                "- [PortSwigger: SSRF](https://portswigger.net/web-security/ssrf)"
            ],
            'business_logic': [
                "- [OWASP: Business Logic Vulnerabilities](https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability)",
                "- [Testing for Business Logic](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README)"
            ]
        }
        
        for key, refs in references.items():
            if key in vuln_type:
                return '\n'.join(refs)
        
        return "- [OWASP Top 10](https://owasp.org/Top10/)"
    
    def _calculate_cvss(self, vulnerability: Dict[str, Any]) -> str:
        """Calculate or estimate CVSS score"""
        severity = vulnerability.get('severity', 'medium').lower()
        
        # Simplified CVSS estimation
        cvss_ranges = {
            'critical': '9.0-10.0',
            'high': '7.0-8.9',
            'medium': '4.0-6.9',
            'low': '0.1-3.9'
        }
        
        return cvss_ranges.get(severity, '5.0')
    
    def generate_curl_command(
        self,
        method: str,
        url: str,
        headers: Optional[Dict[str, str]] = None,
        body: Optional[str] = None
    ) -> str:
        """
        Generate curl command for reproduction
        
        Args:
            method: HTTP method
            url: Target URL
            headers: Request headers
            body: Request body
        
        Returns:
            Formatted curl command
        """
        cmd_parts = [f"curl -X {method}"]
        
        if headers:
            for key, value in headers.items():
                # Redact sensitive headers
                if key.lower() in ['authorization', 'cookie']:
                    value = '[REDACTED]'
                cmd_parts.append(f"  -H '{key}: {value}'")
        
        if body:
            cmd_parts.append(f"  -d '{body}'")
        
        cmd_parts.append(f"  '{url}'")
        
        return ' \\\n'.join(cmd_parts)
    
    def generate_http_log(
        self,
        request: Dict[str, Any],
        response: Dict[str, Any]
    ) -> str:
        """
        Generate HTTP transaction log
        
        Args:
            request: Request data
            response: Response data
        
        Returns:
            Formatted HTTP log
        """
        log_parts = ["### Request\n"]
        
        # Request line
        log_parts.append(f"{request.get('method', 'GET')} {request.get('path', '/')} HTTP/1.1")
        log_parts.append(f"Host: {request.get('host', 'example.com')}")
        
        # Request headers
        for key, value in request.get('headers', {}).items():
            if key.lower() in ['authorization', 'cookie']:
                value = '[REDACTED]'
            log_parts.append(f"{key}: {value}")
        
        # Request body
        if request.get('body'):
            log_parts.append("\n" + request['body'])
        
        log_parts.append("\n### Response\n")
        
        # Response status
        log_parts.append(f"HTTP/1.1 {response.get('status', 200)} {response.get('status_text', 'OK')}")
        
        # Response headers
        for key, value in response.get('headers', {}).items():
            log_parts.append(f"{key}: {value}")
        
        # Response body (truncated if long)
        body = response.get('body', '')
        if len(body) > 500:
            body = body[:500] + "\n... (truncated)"
        log_parts.append("\n" + body)
        
        return '\n'.join(log_parts)
    
    def generate_summary_report(self, all_findings: List[Dict[str, Any]]) -> str:
        """
        Generate summary report of all findings
        
        Args:
            all_findings: List of all vulnerability findings
        
        Returns:
            Summary report
        """
        # Count by severity
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        for finding in all_findings:
            severity = finding.get('severity', 'medium').lower()
            severity_counts[severity] += 1
        
        # Count by type
        type_counts = {}
        for finding in all_findings:
            vuln_type = finding.get('type', 'unknown')
            type_counts[vuln_type] = type_counts.get(vuln_type, 0) + 1
        
        summary = f"""
# AgentZero109 Security Assessment Summary

**Assessment Date:** {datetime.now().strftime('%Y-%m-%d')}  
**Total Findings:** {len(all_findings)}

---

## Severity Breakdown

- **Critical:** {severity_counts['critical']}
- **High:** {severity_counts['high']}
- **Medium:** {severity_counts['medium']}
- **Low:** {severity_counts['low']}

---

## Vulnerability Types

"""
        for vuln_type, count in sorted(type_counts.items(), key=lambda x: x[1], reverse=True):
            summary += f"- **{vuln_type.replace('_', ' ').title()}:** {count}\n"
        
        summary += "\n---\n\n## Key Findings\n\n"
        
        # List critical and high findings
        high_priority = [f for f in all_findings if f.get('severity', '').lower() in ['critical', 'high']]
        for i, finding in enumerate(high_priority[:5], 1):  # Top 5
            title = self._generate_title(finding)
            summary += f"{i}. **{title}** ({finding.get('severity', 'Unknown').upper()})\n"
        
        summary += "\n---\n\n*Report generated by AgentZero109 - AI-powered bug bounty hunting framework*"
        
        return summary
    
    def export_to_json(self, finding: Dict[str, Any]) -> str:
        """Export finding to JSON format"""
        return json.dumps(finding, indent=2, default=str)
    
    def export_to_markdown(self, finding: Dict[str, Any]) -> str:
        """Export finding to Markdown format"""
        evidence = []
        return self.generate_report(finding, evidence)
